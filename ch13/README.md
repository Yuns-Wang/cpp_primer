# 第13章 拷贝控制

## 练习 13.1

拷贝构造函数(coppy constructor):第一个参数是 *自身类型引用* ，并且 *其他参数均有默认值* 的 *构造函数* 。
使用拷贝构造函数的情况：
* "="格式的初始化：`string s = "abcd";`
* 函数中，参数传递和返回值（非引用类型）
* {} 初始化数组或聚合类

## 练习 13.2

`Sales_data::Sales_data(Sales_data rhs);`非法：拷贝构造函数的第一个参数需要是自身类型的引用。`Sales_data::Sales_data(Sales_data& rhs)`
非法版本拷贝构造函数调用时，要将实参赋值给`rhs`，就要调用拷贝构造函数，然后又要赋值给另外的`rhs`，如此无限循环。

## 练习 13.3

* StrBlob: 使用合成的拷贝初始化函数，shared_ptr 被复制给新的类。
* StrBlobPtr: 

## 练习 13.4

`Point foo_bar(Point arg)` 参数传递
`Point local = arg` "="形式初始化
`*heap = new Point(global);` 参数传递
`Point pa[4] = {local, *heap}` {}初始化数组
`return *heap` 函数返回

## [练习 13.5](has_ptr.h)

## 练习 13.6

1. 拷贝赋值运算符：`Foo & operator=(const Foo &);` 
   * **返回自身引用**，为了与内置赋值运算符相同
   * **必须是成员函数**，左侧运算对象默认绑定到this指针，右侧运对象当作参数传入
2. 使用“=”用同类型对象赋值时调用。
3. 默认拷贝赋值运算符作用：
   * 将右侧每个非static成员赋予左侧
   * 禁止使用拷贝赋值运算符
4. 类未定义拷贝赋值运算符时会默认生成。

## 练习 13.7

1. StrBlob：shared_ptr成员会被拷贝复制给左侧成员，增加引用计数
2. StrBlobPtr：

## [练习 13.8](has_ptr.h)

## 练习 13.9

1. 析构函数：`～Foo();`
   * **必须是成员函数**
   * **没有返回值，也没有参数**
2. 首先**执行函数体**，然后**隐式销毁非static成员**，销毁顺序与初始化一致。
3. 在用户没有定义析构函数时

## 练习 13.10

1. StrBlob：shared_ptr成员会调用其析构函数进行销毁
2. StrBlobPtr：
   
## [练习 13.11](has_ptr.h)

## 练习 13.12

3次，函数结束时对item1、item2和accum调用析构函数。
**销毁内置类型不需要析构函数**

## [练习 13.13](c13e13.cpp)

## 练习 13.14

返回相同的序号。

## 练习 13.15

会改变，输出3个不同的序号。4、5、6
输出s(a)、s(b)、s(c)中的序号

## 练习 13.16

会改变输出结果，但是仍然为3个不同序号。1、2、3
输出a、b、c中的序号

## 练习 13.17

[13.14](c13e14.cpp) | [13.15](c13e15.cpp) | [13.16](c13e16.cpp)